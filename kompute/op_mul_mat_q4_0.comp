/**
 * Copyright (c) 2023 Nomic, Inc. All rights reserved.
 *
 * This software is licensed under the terms of the Software for Open Models License (SOM),
 * version 1.0, as detailed in the LICENSE_SOM.txt file. A copy of this license should accompany
 * this software. Except as expressly granted in the SOM license, all rights are reserved by Nomic, Inc.
 */

#version 450

#include "common.comp"

#define LOCAL_SIZE_X_VALUE 8
#define LOCAL_SIZE_Y_VALUE 8
#define LOCAL_SIZE_Z_VALUE 1
#define BLOCKS_IN_QUANT QK4_0
#define SIZE_OF_BLOCK sizeof_block_q4_0
#define N_ROWS 4

#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_EXT_debug_printf : enable

layout(local_size_x = LOCAL_SIZE_X_VALUE,
       local_size_y = LOCAL_SIZE_Y_VALUE,
       local_size_z = LOCAL_SIZE_Z_VALUE) in;

layout (binding = 0) readonly buffer tensorInA { uint8_t inA[]; };
layout (binding = 1) readonly buffer tensorInB { float inB[]; };
layout (binding = 2) writeonly buffer tensorOut { float out_[]; };

layout (push_constant) uniform parameter {
    uint inAOff;
    uint inBOff;
    uint outOff;
    int ne00;
    int ne10;
    int ne0;
    int ne1;
    int ne01;
    int gqa;
} pcs;

void main() {
    const uint nb = uint(pcs.ne00/BLOCKS_IN_QUANT);
    const uint r0 = gl_WorkGroupID.x;
    const uint r1 = gl_WorkGroupID.y;
    const uint im = gl_WorkGroupID.z;
    const uint first_row = (r0 * gl_NumSubgroups + gl_SubgroupID) * N_ROWS;
    const uint offset0 = first_row * nb + im/pcs.gqa*(nb*pcs.ne0);

    const uint x = offset0;           // Based from inA without base offset
    const uint y = r1*uint(pcs.ne10)+im*pcs.ne00*pcs.ne1+pcs.inBOff; // Based from inB

    float sumf[N_ROWS] = {0.0f, 0.0f, 0.0f, 0.0f};

    const uint ix = gl_SubgroupInvocationID/2;
    const uint il = 8*(gl_SubgroupInvocationID%2);

    uint yb = y + ix * BLOCKS_IN_QUANT + il;

//    debugPrintfEXT("gl_NumSubgroups=%d, gl_SubgroupID=%d, gl_SubgroupInvocationID=%d, glSubgroupSize=%d, gl_WorkGroupID.x=%d, gl_WorkGroupID.y=%d\n",
//        gl_NumSubgroups, gl_SubgroupID, gl_SubgroupInvocationID, gl_SubgroupSize,
//        gl_WorkGroupID.x, gl_WorkGroupID.y);

    for (uint ib = ix; ib < nb; ib += gl_SubgroupSize/2) { // FIXME: we need to figure out if group size is not 32??
        for (int row = 0; row < N_ROWS; row++) {
            vec2 acc = vec2(0.0, 0.0);
            const uint index = (x + ib + row * nb) * SIZE_OF_BLOCK + pcs.inAOff;
            float d = float(u8BufToFloat16(inA, index));
            float sumy = 0.0f;
            for (int i = 0; i < 8; i+=2) {
                const uint16_t b = u8BufToU16(inA, index + 2 + il + i);

                const float yl0 = inB[yb + i];
                const float yl1 = inB[yb + i + 1];
                const float yl8 = inB[yb + i + 16];
                const float yl9 = inB[yb + i + 17];

                sumy += yl0 + yl1 + yl8 + yl9;

                acc[0] += yl0 * (b & 0x000F) + yl1 / 256.f * (b & 0x0F00);
                acc[1] += yl8 / 16.f * (b & 0x00F0) + yl9 / 4096.f * (b & 0xF000);
            }
            sumf[row] += d * (sumy * -8.f + acc[0] + acc[1]);
        }

        yb += BLOCKS_IN_QUANT * 16;
    }

    for (int row = 0; row < N_ROWS; ++row) {
        const float tot = subgroupAdd(sumf[row]);
        if (first_row + row < pcs.ne01 && subgroupElect()) {
            out_[r1*pcs.ne0 + im*pcs.ne0*pcs.ne1 + first_row + row + pcs.outOff] = tot;
        }
    }
}
