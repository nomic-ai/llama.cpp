/**
 * Copyright (c) 2023 Nomic, Inc. All rights reserved.
 *
 * This software is licensed under the terms of the Software for Open Models License (SOM),
 * version 1.0, as detailed in the LICENSE_SOM.txt file. A copy of this license should accompany
 * this software. Except as expressly granted in the SOM license, all rights are reserved by Nomic, Inc.
 */

#version 450

#include "common.comp"

layout(local_size_x = 1) in;

layout (binding = 0) readonly buffer tensorInA { uint8_t inA[]; };
layout (binding = 1) readonly buffer tensorInB { int inB[]; };
layout (binding = 2) writeonly buffer tensorOut { float out_[]; };

layout (push_constant) uniform parameter {
    uint inAOff;
    uint inBOff;
    uint outOff;
    int ne00;
    int nb01;
    int nb1;
} pcs;

#define UNALIGNED_INPUT inA

block_q4_1 get_unaligned_block_q4_1(uint index) {
    block_q4_1 fres;
    fres.d = u8BufToFloat16(UNALIGNED_INPUT, index);
    fres.m = u8BufToFloat16(UNALIGNED_INPUT, index+2);
    [[unroll]] for (uint it = 0; it != QK4_1 / 2; it++) {
        fres.qs[it] = UNALIGNED_INPUT[index+4+it];
    }
    return fres;
}

void dequantize_row_q4_1(uint x /*Based from inA unaligned*/, uint y /*Based from out_*/, int k) {
    const uint qk = QK4_1;

    const uint nb = k / qk;

    for (uint i = 0; i < nb; i++) {
        const block_q4_1 block = get_unaligned_block_q4_1(x + i*sizeof_block_q4_0);

        const float16_t d = block.d;
        const float16_t m = block.m;

        for (uint j = 0; j < qk/2; ++j) {
            const int x0 = (block.qs[j] & 0x0F);
            const int x1 = (block.qs[j] >>   4);

            out_[y+i*qk + j + 0   ] = float(x0)*d + m;
            out_[y+i*qk + j + qk/2] = float(x1)*d + m;
        }
    }
}

void main() {
    const uint i = gl_WorkGroupID.x;
    const int r = inB[i + pcs.inBOff];

    dequantize_row_q4_1(uint(r*pcs.nb01) + pcs.inAOff, uint(i*pcs.nb1/4) + pcs.outOff, pcs.ne00);
}
